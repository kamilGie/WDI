# ASRT-WDI 
## Automatyczne Szablony, RozwiÄ…zania i Testy do WDI na AGH
### ğŸ”§ UÅ¼ywanie Projektu

KaÅ¼dy folder z zadaniem skÅ‚ada siÄ™ z czterech skÅ‚adnikÃ³w:

1. **`README.md`** â€“ zawiera treÅ›Ä‡ zadania, **gÅ‚Ã³wne rozwiÄ…zanie** oraz, okazjonalnie, opis rozwiÄ…zania.
2. **`RozwiÄ…zania`** â€“ folder zawierajÄ…cy gotowe rozwiÄ…zania zadania.
3. **`szablon.py`** â€“ plik zawierajÄ…cy szablon do wypeÅ‚nienia wÅ‚asnym rozwiÄ…zaniem.
4. **`testy.py`** â€“ plik z testami jednostkowymi.


### ğŸ§ª Jak testowaÄ‡ swoje rozwiÄ…zania?

WypeÅ‚nij plik `szablon.py` i uruchom go, odkomentowujÄ…c funkcjÄ™ `odpal_testy()`

https://github.com/user-attachments/assets/ad6d166e-bda7-4eca-a8cc-86d984913e0f

### ğŸŒ Wizualizacje RozwiÄ…zaÅ„

NiektÃ³re zadania zawierajÄ… wizualne wyjaÅ›nienia algorytmÃ³w, ktÃ³re sÄ… hostowane w chmurze na stronie internetowej lub zrealizowane w Pygame, na przykÅ‚ad [Kolokwium 2022 A3](https://github.com/kamilGie/ASRT-WDI/tree/main/Kolokwia/Kolokwium_2/2022_A3), [160](https://github.com/kamilGie/ASRT-WDI/tree/main/Zestaw_5%3A_Rekurencja/160) czy [148](https://github.com/kamilGie/ASRT-WDI/tree/main/Zestaw_5%3A_Rekurencja/148) 

### ğŸŒ‘ Czarny Motyw Zestawu
KaÅ¼dy zestaw oraz kaÅ¼de zadanie zawiera plik `README` z opisem zadaÅ„. JeÅ›li masz ustawiony czarny motyw na GitHubie, zestaw ten bÄ™dzie wyÅ›wietlany w ciemnej wersji.


### ğŸ› ZgÅ‚aszanie BÅ‚Ä™dÃ³w
BÅ‚Ä™dy w rozwiÄ…zaniach, testach lub treÅ›ciach zgÅ‚aszaj na <a href="https://github.com/kamilgie/ASRT-WDI/issues/new?labels=bug">****Issues****</a> lub <a href="https://gieras.pl/">****prywatnie****</a>.

### ğŸ§± Prototypy
NierozwiÄ…zane zadania znajdujÄ… siÄ™ w plikach `prototyp.py` i czekajÄ… na rozwiÄ…zanie. Po rozwiÄ…zaniu zadania moÅ¼na stworzyÄ‡ peÅ‚ne zadanie, automatycznie generujÄ…c wszystkie pliki.


<details>
   
   <summary> Tworzenie ZadaÅ„ na prototypie </summary>

1. Po rozwiÄ…zaniu zadania na `prototyp.py` moÅ¼na stworzyÄ‡ peÅ‚ne zadanie, odkomentowujÄ…c funkcjÄ™ `stworz_zadanie` i przekazujÄ…c w tablicy funkcje, ktÃ³re majÄ… byÄ‡ objÄ™te testami.
2. Funkcja `stworz_zadanie` automatycznie przygotuje testy na podstawie przekazanych funkcji. Poprosi rÃ³wnieÅ¼ o podanie argumentÃ³w testowych, ktÃ³re Twoim zdaniem mogÄ… byÄ‡ interesujÄ…ce lub problematyczne.
3. NastÄ™pnie utworzy folder zadania zawierajÄ…cy pliki: `rozwiazanie.py` oraz `szablon.py` na podstawie `prototyp.py`, a takÅ¼e `testy.py` na podstawie wczeÅ›niej wygenerowanych testÃ³w.

https://github.com/user-attachments/assets/f3316918-a5e9-457f-8c2e-b4a5e5f0f27c



</details>


 
---

## Å¹rÃ³dÅ‚a rozwiÄ…zaÅ„ ğŸ“š

CzÄ™Å›Ä‡ rozwiÄ…zaÅ„ zostaÅ‚a zaczerpniÄ™ta (*bezczelnie podkradziona*) z poniÅ¼szych repozytoriÃ³w.  
Jestem ogromnie wdziÄ™czny ich autorom za Å›wietne prace, ktÃ³re bardzo pomogÅ‚y! 

- ğŸŒŸ [WDI-2023](https://github.com/pawlowiczf/WDI-2023) - [Filip PawÅ‚owicz](https://github.com/pawlowiczf)
- ğŸŒŸ [bit-algo-start-24-25-WDI](https://github.com/MarcinSerafin03/bit-algo-start-24-25-WDI) - [Marcin Serafin](https://github.com/MarcinSerafin03) ,[Ernest Szlamczyk](https://github.com/eszlamczyk) 
- ğŸŒŸ [WDI2020](https://github.com/Wisien999/WDI2020) - [Wisien999](https://github.com/Wisien999)  




### ğŸ—¿ NajwiÄ™ksi wspÃ³Å‚twÃ³rcy:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="https://github.com/kamilGie/ASRT-WDI/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=kamilGie/ASRT-WDI" alt="NajwiÄ™ksi wspÃ³Å‚twÃ³rcy" />
</a>




# SzczegÃ³Å‚y Projektu

<details>
  <summary> ğŸ¤ Jak pomÃ³c i zostaÄ‡ wspÃ³Å‚twÃ³rcÄ…? </summary>

## ğŸ¤ Jak pomÃ³c i zostaÄ‡ wspÃ³Å‚twÃ³rcÄ…?


- Zalecam [***utworzenie forka***](https://github.com/kamilGie/WDI/fork) oraz samodzielne stworzenie zadania i zgÅ‚aszanie swoich zmian za pomocÄ… pull requestÃ³w.
- MoÅ¼na rÃ³wnieÅ¼ [dodaÄ‡ rozwiÄ…zanie zadania](https://github.com/kamilGie/ASRT-WDI/new/main/bufor_rozwi%C4%85za%C5%84), nie wychodzÄ…c z przeglÄ…darki, korzystajÄ…c z opcji "dodaj plik" w folderze bufor rozwiÄ…zaÅ„. W wolnym czasie bÄ™dÄ™ z nich tworzyÅ‚ zadania. SzczegÃ³Å‚y znajdziesz w [README folderu bufor rozwiÄ…zaÅ„](/bufor_rozwiÄ…zaÅ„).


### ğŸ’¡ MoÅ¼liwe Ulepszenia ### 
- âœï¸ Stworzenie Zadania
- ğŸ› ï¸ Poprawienie treÅ›ci zadania, jeÅ›li jest niejasna lub brakuje np. znakÃ³w potÄ™gowania.
- ğŸ”§ Ulepszanie testow poprzez komendy lub stworzeniej wÅ‚asnej [SzczegÃ³Å‚y](#komendy)
- ğŸ§  Tworzenie Strategi Tworzenia ZadaÅ„ [SzczegÃ³Å‚y](#strategie)
  
SRT opiera siÄ™ na **rozszerzaniu funkcjonalnoÅ›ci**. DziÄ™ki temu moÅ¼esz dodawaÄ‡ nowe funkcje i strategie bez modyfikacji istniejÄ…cego kodu, co uÅ‚atwia wdroÅ¼enie bez potrzeby wiedzy o caÅ‚ym systemie i unika konfliktÃ³w.
### ğŸ› ZgÅ‚aszanie bÅ‚Ä™dÃ³w

- BÅ‚Ä™dy w rozwiÄ…zaniach, testach lub treÅ›ciach moÅ¼na zgÅ‚aszaÄ‡ <a href="https://github.com/kamilgie/ASRT-WDI/issues/new?labels=bug"> ****tutaj**** </a>

### ğŸ’¬ Feedback

- Sam feedback na temat tego, jak siÄ™ pracuje, w jakim kierunku moÅ¼na pÃ³jÅ›Ä‡ oraz czego brakuje, rÃ³wnieÅ¼ bÄ™dzie mile widziany. [kontakt](http://www.gieras.pl).


</details>



<details>
  <summary> ğŸ§ª Testowanie Zadania </summary>

## Testowanie Zadania
PrzykÅ‚adowy `szablon.py` wyglÄ…da tak: 
```python
# ====================================================================================================>
# Zadanie 1
# ProszÄ™ napisaÄ‡ program poszukujÄ…cy trÃ³jkÄ…tÃ³w Pitagorejskich w ktÃ³rych dÅ‚ugoÅ›Ä‡ przekÄ…tnej
# jest mniejsza od liczby N wprowadzonej z klawiatury.
# ====================================================================================================>
# print(a,b,c)

def Zadanie_1(n): ...


if __name__ == "__main__":
    from testy01 import odpal_testy

    Zadanie_1(input('Podaj n: '))

    # odpal_testy()
```
### Na gÃ³rze znajduje siÄ™ opis zadania, funkcja do wypeÅ‚nienia i przygotowany main.
WypeÅ‚niasz funkcjÄ™ kodem, o ktÃ³ry prosi opis zadania. Wyniki moÅ¼na zwracaÄ‡ lub wypisywaÄ‡. JeÅ›li to nie bÄ™dzie oczywiste, pod opisem zadania powinna byÄ‡ wskazÃ³wka od autora testÃ³w, jakiego sposobu zwracania wynikÃ³w oczekuje. W tym przypadku widaÄ‡, Å¼e boki trÃ³jkÄ…ta powinny byÄ‡ wypisywane kolejno, bez Å¼adnych dodatkowych napisÃ³w.

Po tym, jak zrobisz zadanie i bÄ™dziesz pewny jego poprawnoÅ›ci, moÅ¼esz odkomentowaÄ‡ funkcjÄ™ `odpal_testy()` i uruchomiÄ‡ program normalnie:
```python
# ====================================================================================================>
# Zadanie 1
# ProszÄ™ napisaÄ‡ program poszukujÄ…cy trÃ³jkÄ…tÃ³w Pitagorejskich w ktÃ³rych dÅ‚ugoÅ›Ä‡ przekÄ…tnej
# jest mniejsza od liczby N wprowadzonej z klawiatury.
# ====================================================================================================>
# print(a,b,c)

def Zadanie_1(n):
    for a in range(1, n):
        for b in range(a, n):
            c = (a * a + b * b) ** 0.5
            if c.is_integer() and c <= n:
                print(a, b, c)

if __name__ == "__main__":
     from testy01 import odpal_testy

     odpal_testy()
```
### wynik takiego programu dalby taki wynik
<img width="1504" alt="Zrzut ekranu 2024-10-24 o 22 26 09" src="https://github.com/user-attachments/assets/666313c3-15ec-4697-955c-1e5de81e23d7">
  
Wynik testu wskazuje na bÅ‚Ä…d: widzimy komunikat `AssertionError: '3 4 5' not found in [''].` Oznacza to, Å¼e test oczekiwaÅ‚ pustego stringa `''`, a otrzymaÅ‚ `'3 4 5'`, co sugeruje, Å¼e wynik dla c = 5 zostaÅ‚ niepotrzebnie wypisany.

Po chwili namysÅ‚u i ponownym przeczytaniu treÅ›ci zadania, moÅ¼na zauwaÅ¼yÄ‡, Å¼e warunek mÃ³wi o dÅ‚ugoÅ›ci przekÄ…tnej mniejszej, niÅ¼ liczba **N**. Kod naleÅ¼y poprawiÄ‡ i ponownie uruchomiÄ‡ testy z nowÄ… nadziejÄ….

### Czasami moÅ¼na spotkaÄ‡ siÄ™ z takim przypadkiem:
 <img width="1165" alt="Zrzut ekranu 2024-10-24 o 22 57 49" src="https://github.com/user-attachments/assets/4fe66d52-766c-417a-87ab-738a38271137">
Widzimy, Å¼e mimo poprawnego wyniku mamy bÅ‚Ä™dny test, poniewaÅ¼ wypisujemy wynik w innym typie lub kolejnoÅ›ci. W takim przypadku moÅ¼emy:

- CieszyÄ‡ siÄ™ poprawnym rozwiÄ…zaniem i pÃ³jÅ›Ä‡ dalej.
- ZmieniÄ‡ typ lub format wyjÅ›cia na taki, jaki jest oczekiwany w teÅ›cie.
- ZainteresowaÄ‡ siÄ™ pomocÄ… w rozwijaniu projektu i za pomocÄ… komendy dodaÄ‡ swojÄ… funkcjÄ™ wraz z jej rozwiÄ…zaniem do listy poprawnych odpowiedzi, aby inni uÅ¼ytkownicy mieli dobre testy dla takich samych wynikÃ³w jak twÃ³j.

WiÄ™cej o tym, jak dziaÅ‚a caÅ‚y projekt w 


  
---
</details>

<details>
  <summary> âœï¸  Tworzenie Zadania z prototypu  </summary>

## Tworzenie Zadania
### `stworz_zadanie()` 
KaÅ¼dy prototyp zawiera funkcjÄ™ `stworz_zadanie`, importowanÄ… z pliku `Develop`. Funkcja `stworz_zadanie` przesyÅ‚a funkcje, ktÃ³re chcemy by obejmowaÅ‚y testy oraz wchodziÅ‚y w skÅ‚ad szablonu do wypelnienia. Wiec przykÅ‚adowo wypeÅ‚niony `prototyp` powinnien wygladaÄ‡ tak:
```python
# ====================================================================================================>
# Zadanie 0
# Stworz 2 funkcje jedna dodaje 2 liczby druga mnoÅ¼y 2 liczby
# ====================================================================================================>

def dodaj(a, b):
    return a + b

def mnoÅ¼(a, b):
    return a * b

if __name__ == "__main__":
    from Develop import stworz_zadanie

    # stworz_zadanie([dodaj, mnoÅ¼])
```

Funkcja `stworz_zadanie` dziaÅ‚a podobnie jak funkcja `print`. MoÅ¼na jÄ… uruchomiÄ‡ bez dodatkowych parametrÃ³w, aby wygenerowaÄ‡ domyÅ›lnÄ… strukturÄ™ plikÃ³w: `rozwiazanie.py`, `testy.py` oraz `szablon.py`. 

### Modyfikacje 

MoÅ¼na modyfikowaÄ‡ sposÃ³b, w jaki generowane sÄ… pliki, ustawiajÄ…c argumenty nazw plikÃ³w. Modyfikacje sÄ… podawane jako stringi, ktÃ³re okreÅ›lajÄ…  strategie, z jakÄ… wygenerujÄ… siÄ™ pliki. Dla podstawowego uÅ¼ycia projektu przydatne bÄ™dÄ… trzy modyfikacje:

```python
stworz_zadanie([dodaj, mnoÅ¼], testy="float")
```
- Stworzy testy, ktÃ³rych wyniki bÄ™dÄ… zaokrÄ…glone. Przydatne w zadaniach zwracajÄ…cych wartoÅ›ci typu `float`, gdzie wyniki mogÄ… siÄ™ rÃ³Å¼niÄ‡ od ustawionego epsilonu.
  
```python
stworz_zadanie([dodaj, mnoÅ¼], testy="bez_kolejnosci")
```
- Stworzy testy, ktÃ³rych wyniki bÄ™dÄ… w typie `set`. Przydatne w zadaniach, w ktÃ³rych kolejnoÅ›Ä‡ lub czÄ™stotliwoÅ›Ä‡ wystÄ™powania wynikÃ³w nie ma znaczenia.
```python
stworz_zadanie([dodaj, mnoÅ¼], testy="brak", szablon="brak")
```
- Nie stworzy pliku. Przydatne w zadaniach abstrakcyjnych, ktÃ³re nie sÄ… moÅ¼liwe do przetestowania.

DokÅ‚adniej o modyfikacjach jest w sekcji [strategie](#Strategie)

<details>
   <summary> DomyÅ›lna konfiguracja plikÃ³w </summary>

### `rozwiazanie.py` 
1. przepisuje prototyp do napotkania linijki main
```python
# ====================================================================================================>
# Zadanie 0
# Stworz 2 funkcje jedna dodaje 2 liczby druga mnoÅ¼y dwie liczby
# ====================================================================================================>

def dodaj(a, b):
    return a + b

def mnoÅ¼(a, b):
    return a * b

```
### `szablon.py` 
1. Przepisuje pierwsze linie, ktÃ³re sÄ… komentarzami, aby zostawiÄ‡ opis zadania wraz z ewentualnymi komentarzami twÃ³rcy zadania.
2. NastÄ™pnie usuwa wszystkie linijki poza linijkÄ… zaczynajÄ…cÄ… siÄ™ od `def FunkcjaKtoraTestujemy(`. TÄ™ linijkÄ™ pozostawia i dopisuje trzy kropki, aby uÅ¼ytkownik wiedziaÅ‚, Å¼e te funkcje sÄ… do napisania.
3. Usuwa wszystkie linie do momentu napotkania bloku `if __name__ == "__main__":`.
4. Zapisuje import funkcji `odpal_testy`.
5. Zapisuje uruchomienie funkcji, ktÃ³re testujemy, wraz z dynamicznym wprowadzeniem nazw ich argumentÃ³w.
6. Zakomentowana metoda `odpal_testy()`, ktÃ³ra bÄ™dzie uruchamiaÄ‡ testy.

```python
# ====================================================================================================>
# Zadanie 0
# Stworz 2 funkcje jedna dodaje 2 liczby druga mnoÅ¼y dwie liczby
# ====================================================================================================>

def dodaj(a, b): ...

def mnoÅ¼(a, b): ...

if __name__ == "__main__":
    from testy01 import odpal_testy

    dodaj(input('Podaj a: '), input('Podaj b: '))
    mnoÅ¼(input('Podaj a: '), input('Podaj b: '))

    # odpal_testy()
```

### `testy.py` 
1. Napisze  importy, funkcje oraz  nagÅ‚Ã³wek klasy `Testy`
2. NastÄ™pnie dla kaÅ¼dej funkcji przekazanej do testowania:
3. Sprawdza liczbÄ™ argumentÃ³w, jakÄ… funkcja przyjmuje.
4. JeÅ›li liczba argumentÃ³w nie wynosi zero, prosi uÅ¼ytkownika o wpisanie argumentÃ³w testowych.
5. Przetwarza input uÅ¼ytkownika, zmieniajÄ…c go na argumenty wedÅ‚ug algorytmÃ³w.
6. Uruchamia funkcjÄ™ z argumentami testowymi, monitorujÄ…c jednoczeÅ›nie wartoÅ›ci wypisywane przez `print` oraz wartoÅ›ci zwracane przez funkcjÄ™.
7. JeÅ›li funkcja nic nie zwrÃ³ci, wynikiem zostanie to, co zostaÅ‚o przechwycone przez `print`. JeÅ›li funkcja zwrÃ³ci innÄ… wartoÅ›Ä‡, to ona bÄ™dzie wynikiem, a dane wypisane przez `print` zostanÄ… zignorowane.
8. Z argumentÃ³w i wyniku napisze metodÄ™ testowÄ… o nazwie `test_numerTestu_funkcjaTestowalna_argument`.
```python
    def test_Nr1_dodaj_argumenty_2_2(self):
        wynik  = dodaj(2, 2)

        oczekiwany_wynik = [4]
        self.assertIn(wynik, oczekiwany_wynik)
```
9. BÄ™dzie powtarzaÄ‡ proces od punktÃ³w 3â€“8, aÅ¼ do napotkania argumentu `stop` od uÅ¼ytkownika, ktÃ³ry zakoÅ„czy testy.

<details>
   <summary>Pelny kod testy przykladu </summary>
   
```python 
import unittest
import io
import os
import sys
from contextlib import redirect_stdout
import importlib

from szablon01 import dodaj, mnoÅ¼


def odpal_testy():
    suite = unittest.TestLoader().loadTestsFromTestCase(testy)
    unittest.TextTestRunner(verbosity=2).run(suite)


def komenda(k: str, *args, **kwargs):
    """
    Wykonuje zadanÄ… komendÄ™ z przekazanymi argumentami.
    Dodanie wÅ‚asnej komendy ogranicza sie do dodania pliku z funkcja o tej samej nazwie
    w folderze glÃ³wnym projektu src/Komendy
    Wiecej informacji o dodaniu wlasnej komendy jak i lista komend w ReadMe projektu

    Args:
        k (str): Komenda do wykonania.
        *args: Dodatkowe argumenty do komendy.
        **kwargs: Dodatkowe argumenty kluczowe do komendy.
    """
    sciezka_pliku_wykonalnego = os.path.abspath(sys.argv[0])
    srt_dir = os.path.join(
        os.path.dirname(sciezka_pliku_wykonalnego), "../../srt"
    )
    sys.path.append(srt_dir)
    nr_zadania = os.path.dirname(sciezka_pliku_wykonalnego)
    return importlib.import_module("WykonajKomende").wykonaj_komende(
        k, sciezka_pliku_wykonalnego, nr_zadania, *args, **kwargs
    )


class testy(unittest.TestCase):

    def test_Nr1_dodaj_argumenty_2_2(self):
        wynik  = dodaj(2, 2)

        oczekiwany_wynik = [4]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr2_dodaj_argumenty_14_123(self):
        wynik  = dodaj(14, 123)

        oczekiwany_wynik = [137]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr3_dodaj_argumenty_123_123(self):
        wynik  = dodaj(123, 123)

        oczekiwany_wynik = [246]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr4_dodaj_argumenty_123_1123(self):
        wynik  = dodaj(123, 1123)

        oczekiwany_wynik = [1246]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr5_dodaj_argumenty_12_3123(self):
        wynik  = dodaj(12, 3123)

        oczekiwany_wynik = [3135]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr6_dodaj_argumenty_12_3123(self):
        wynik  = dodaj(12, 3123)

        oczekiwany_wynik = [3135]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr7_dodaj_argumenty_-213_12312(self):
        wynik  = dodaj(-213, 12312)

        oczekiwany_wynik = [12099]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr8_dodaj_argumenty_2_2(self):
        wynik  = dodaj(2, 2)

        oczekiwany_wynik = [4]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr9_dodaj_argumenty_2_4(self):
        wynik  = dodaj(2, 4)

        oczekiwany_wynik = [6]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr10_dodaj_argumenty_2_-1(self):
        wynik  = dodaj(2, -1)

        oczekiwany_wynik = [1]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr11_dodaj_argumenty_2913_123(self):
        wynik  = dodaj(2913, 123)

        oczekiwany_wynik = [3036]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr12_dodaj_argumenty_324_56234(self):
        wynik  = dodaj(324, 56234)

        oczekiwany_wynik = [56558]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr13_dodaj_argumenty_21_35(self):
        wynik  = dodaj(21, 35)

        oczekiwany_wynik = [56]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr14_dodaj_argumenty_12_4(self):
        wynik  = dodaj(12, 4)

        oczekiwany_wynik = [16]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr15_dodaj_argumenty_0_0(self):
        wynik  = dodaj(0, 0)

        oczekiwany_wynik = [0]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr16_dodaj_argumenty_-1_-1(self):
        wynik  = dodaj(-1, -1)

        oczekiwany_wynik = [-2]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr17_dodaj_argumenty_1_1(self):
        wynik  = dodaj(1, 1)

        oczekiwany_wynik = [2]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr18_dodaj_argumenty_12_23(self):
        wynik  = dodaj(12, 23)

        oczekiwany_wynik = [35]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr19_dodaj_argumenty_2_1(self):
        wynik  = dodaj(2, 1)

        oczekiwany_wynik = [3]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr20_dodaj_argumenty_2_5(self):
        wynik  = dodaj(2, 5)

        oczekiwany_wynik = [7]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr21_dodaj_argumenty_21_1(self):
        wynik  = dodaj(21, 1)

        oczekiwany_wynik = [22]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr1_mnoÅ¼_argumenty_213_4512(self):
        wynik  = mnoÅ¼(213, 4512)

        oczekiwany_wynik = [961056]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr2_mnoÅ¼_argumenty_-4_12(self):
        wynik  = mnoÅ¼(-4, 12)

        oczekiwany_wynik = [-48]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr3_mnoÅ¼_argumenty_-3_-2(self):
        wynik  = mnoÅ¼(-3, -2)

        oczekiwany_wynik = [6]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr4_mnoÅ¼_argumenty_0_0(self):
        wynik  = mnoÅ¼(0, 0)

        oczekiwany_wynik = [0]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr5_mnoÅ¼_argumenty_-231_-2312(self):
        wynik  = mnoÅ¼(-231, -2312)

        oczekiwany_wynik = [534072]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr6_mnoÅ¼_argumenty_23_1(self):
        wynik  = mnoÅ¼(23, 1)

        oczekiwany_wynik = [23]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr7_mnoÅ¼_argumenty_231_213(self):
        wynik  = mnoÅ¼(231, 213)

        oczekiwany_wynik = [49203]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr8_mnoÅ¼_argumenty_21_-123(self):
        wynik  = mnoÅ¼(21, -123)

        oczekiwany_wynik = [-2583]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr9_mnoÅ¼_argumenty_52_1(self):
        wynik  = mnoÅ¼(52, 1)

        oczekiwany_wynik = [52]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr10_mnoÅ¼_argumenty_3213_-3212(self):
        wynik  = mnoÅ¼(3213, -3212)

        oczekiwany_wynik = [-10320156]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr11_mnoÅ¼_argumenty_-1_12(self):
        wynik  = mnoÅ¼(-1, 12)

        oczekiwany_wynik = [-12]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr12_mnoÅ¼_argumenty_3_212(self):
        wynik  = mnoÅ¼(3, 212)

        oczekiwany_wynik = [636]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr13_mnoÅ¼_argumenty_213_123(self):
        wynik  = mnoÅ¼(213, 123)

        oczekiwany_wynik = [26199]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr14_mnoÅ¼_argumenty_123_213(self):
        wynik  = mnoÅ¼(123, 213)

        oczekiwany_wynik = [26199]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr15_mnoÅ¼_argumenty_54_6435(self):
        wynik  = mnoÅ¼(54, 6435)

        oczekiwany_wynik = [347490]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr16_mnoÅ¼_argumenty_435_43(self):
        wynik  = mnoÅ¼(435, 43)

        oczekiwany_wynik = [18705]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr17_mnoÅ¼_argumenty_34_5345(self):
        wynik  = mnoÅ¼(34, 5345)

        oczekiwany_wynik = [181730]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr18_mnoÅ¼_argumenty_34_53(self):
        wynik  = mnoÅ¼(34, 53)

        oczekiwany_wynik = [1802]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr19_mnoÅ¼_argumenty_3_45(self):
        wynik  = mnoÅ¼(3, 45)

        oczekiwany_wynik = [135]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr20_mnoÅ¼_argumenty_3_3(self):
        wynik  = mnoÅ¼(3, 3)

        oczekiwany_wynik = [9]
        self.assertIn(wynik, oczekiwany_wynik)

    def test_Nr21_mnoÅ¼_argumenty_345_34(self):
        wynik  = mnoÅ¼(345, 34)

        oczekiwany_wynik = [11730]
        self.assertIn(wynik, oczekiwany_wynik)


```

</details>

</details>

---

## Pisanie TestÃ³w


Po uruchomieniu funkcji `stworz_testy`, jeÅ›li liczba argumentÃ³w przekazanych do testowania funkcji nie wynosi zero, program poprosi uÅ¼ytkownika o wpisanie argumentÃ³w testowych.

- Argumenty naleÅ¼y wpisywaÄ‡, oddzielajÄ…c je spacjami lub przecinkami.
  <img width="723" alt="Zrzut ekranu 2024-11-7 o 00 47 45" src="https://github.com/user-attachments/assets/ab503d2a-321c-494b-be07-0fe6a90e959c">

- Tablice wpisuje siÄ™, uÅ¼ywajÄ…c nawiasÃ³w kwadratowych, przy czym dozwolone jest zagnieÅ¼dÅ¼anie tablic dowolnÄ… iloÅ›Ä‡ razy.
  <img width="724" alt="Zrzut ekranu 2024-11-7 o 00 02 27" src="https://github.com/user-attachments/assets/763ca1e4-913b-4f47-8a17-1abff1997f7e">

- Stringi naleÅ¼y podaÄ‡ w cudzysÅ‚owach, a takÅ¼e moÅ¼liwe jest zagnieÅ¼dÅ¼anie cudzysÅ‚owÃ³w.
  <img width="724" alt="Zrzut ekranu 2024-11-7 o 00 07 02" src="https://github.com/user-attachments/assets/bb138ead-76c4-46c3-a529-2309042c9fa1">

- JeÅ›li argumenty wpisane bÄ™dÄ… siÄ™ nie zgadzaÄ‡, program poprosi o ponowne ich wprowadzenie.
  <img width="724" alt="Zrzut ekranu 2024-11-7 o 00 40 42" src="https://github.com/user-attachments/assets/61400923-4454-4aba-95c4-656b6eebc3e7">

Po stworzeniu odpowiedniej iloÅ›ci testÃ³w, moÅ¼na zakoÅ„czyÄ‡ proces tworzenia testÃ³w, podajÄ…c argument `stop`, co zakoÅ„czy TwÃ³j wkÅ‚ad w tworzenie testÃ³w.

###  Finalizacja

Po stworzeniu trzech plikÃ³w funkcja utworzy plik `prototypBackup.py`, aby bezpiecznie mÃ³c usunÄ…Ä‡ prototyp. Plik `prototypBackup.py` jest ignorowany przez `.gitignore`, wiÄ™c nie bÄ™dzie dodawany do gÅ‚Ã³wnego repozytorium. ZostaÅ‚ stworzony, aby w przypadku bÅ‚Ä™dnego stworzenia zadania z rÃ³Å¼nych powodÃ³w mÃ³c utworzyÄ‡ zadanie na nowo. Funkcja `stworz_zadanie` dba o to, by nie usunÄ…Ä‡ pliku `prototypBackup`, dziÄ™ki czemu moÅ¼na tworzyÄ‡ zadania do momentu zadowolenia z efektu koÅ„cowego.

Na tym koÅ„czy siÄ™ funkcja `stworz_zadanie`. JeÅ›li jednak komuÅ› nie podoba siÄ™ sposÃ³b w jaki pliki `rozwiazanie.py`, `szablon.py`, `testy.py` sÄ… tworzone, chciaÅ‚by dodaÄ‡ jakÄ…Å› funkcjonalnoÅ›Ä‡ lub inaczej tworzyÄ‡ testy zawsze moÅ¼e stworzyÄ‡ wÅ‚asnÄ… StrategiÄ™!

---
</details>

<details>
  <summary>ğŸ§  Strategie</summary>

## Strategie
Strategie definiujÄ… sposÃ³b, w jaki bÄ™dziemy tworzyÄ‡ nasze pliki w projekcie. Aktualna lista strategii znajduje siÄ™ w folderach o odpowiednich nazwach: [srt/Szablon](srt/Szablon), [srt/Rozwiazania](srt/Rozwiazania), [srt/Testy](srt/Testy). KaÅ¼da z nich jest klasÄ… z krÃ³tkim komentarzem opisujÄ…cym jej przeznaczenie i jest dostÄ™pna do uÅ¼ycia przez kaÅ¼dego twÃ³rcÄ™ zadania. 

Taki ukÅ‚ad projektu pozwala na prosty rozwÃ³j i umoÅ¼liwia rozwijanie go przez kaÅ¼dego, bez potrzeby znajomoÅ›ci caÅ‚ego systemu. KaÅ¼dy moÅ¼e napisaÄ‡ wÅ‚asnÄ… klasÄ™ domyÅ›lnÄ…, ktÃ³ra bÄ™dzie nastÄ™pnie testowana w uÅ¼yciu. Po tym, jak stanie siÄ™ powszechniejsza, szybsza lub lepsza, zostanie ustawiona jako domyÅ›lna. MoÅ¼na rÃ³wnieÅ¼ dodaÄ‡ klasÄ™ dodatkowÄ…, ktÃ³ra obsÅ‚uguje testy dla okreÅ›lonej puli zadaÅ„, dla ktÃ³rych domyÅ›lne tworzenie zadania nie jest wystarczajÄ…ce.


### Podstawy Pisania Strategii

Stworzymy kilka przykÅ‚adowych klas strategii:

- **`Data`** â€“ Jest to strategia szablonu, ktÃ³ra dziaÅ‚a jak domyÅ›lna, z tÄ… rÃ³Å¼nicÄ…, Å¼e na gÃ³rze pliku zostanie dodana data rozwiÄ…zania.
  
W folderze [srt/Szablon](srt/Szablon), tworzymy nowy plik z klasa o takiej samej nazwie. Klasa dziedziczy po jednej z klas w jej folderze albo po klasie bazowej. Klasa [srt/Bazowa.py](srt/Bazowa.py) jest abstrakcyjnÄ… klasÄ…, z ktÃ³rej bÄ™dÄ… pochodziÄ‡ wszystkie klasy pochodne.

Klasa bazowa ma abstrakcyjnÄ… metodÄ™ `__str__`, w ktÃ³rej musimy zwrÃ³ciÄ‡ wynik w postaci stringa, ktÃ³ry pÃ³Åºniej znajdzie siÄ™ w pliku szablonu. Dla naszego pomysÅ‚u ta klasa bÄ™dzie wyglÄ…daÄ‡ tak:

```python
# srt/Szablon/data.py

#  Dziedzicze po klasie z pliku szablonÃ³w do ktÃ³rej metody __str__  mÃ³gÅ‚bym coÅ› dodaÄ‡
from domyslne_s import domyslne_s 
from datetime import date

class data(domyslne_s):
""" na gÃ³rze pliku zostanie dodana data rozwiÄ…zania. """
    def __str__(self):
        res = str(date.today().day)
        res += "\n"
        res += super().__str__()
        return res
```
Tak stworzonÄ… klasÄ™ moÅ¼emy juÅ¼ uÅ¼ywaÄ‡ w funkcji `stworz_zadanie`, podajÄ…c argument `szablon="data"`.

---

- **`meritum`** strategia rozwiazania  ktÃ³ra koncentruje siÄ™ wyÅ‚Ä…cznie na samym rozwiÄ…zaniu, pomijajÄ…c opis zadania oraz sekcjÄ™ `main`

 Aby dostosowaÄ‡ sposÃ³b generowania pliku, moÅ¼na skorzystaÄ‡ z atrybutÃ³w klasy bazowej, ktÃ³re sÄ… dostÄ™pne w klasach pochodnych:

- **`linie_prototypu`** â€“ lista stringÃ³w reprezentujÄ…cych linie prototypu.
- **`nr_zadania`** â€“ numer zadania, ktÃ³re rozwiÄ…zujemy.
- **`funkcje`** â€“ funkcje przekazane do testÃ³w szablonu oraz inne pomocnicze funkcje.
- **`sciezka`** â€“ Å›cieÅ¼ka folderu, w ktÃ³rym znajduje siÄ™ tworzone zadanie.
- **`nazwa_pliku`** â€“ domyÅ›lna nazwa pliku, ktÃ³ra pochodzi od nazwy folderu zawierajÄ…cego klasÄ™. Na przykÅ‚ad, w folderze *Rozwiazanie*, klasy dziedziczÄ…ce majÄ… atrybut ustawiony na "rozwiazanie{`nr_zadania`}.py".

Te atrybuty mogÄ… byÄ‡ wykorzystywane w klasach pochodnych od klasy bazowej, a poniÅ¼ej przedstawiamy przykÅ‚ad uÅ¼ycia jednego z nich.

```python
# srt/Rozwiazanie/meritum.py

from bazowa import bazowa
import inspect

class meritum(bazowa):
    """rozwiazania  ktÃ³ra koncentruje siÄ™ wyÅ‚Ä…cznie na samym rozwiÄ…zaniu, pomijajÄ…c opis zadania oraz sekcjÄ™ `main`"""

    def __str__(self):
        res = ""
        for funkcja in self.funkcje:
            res += inspect.getsource(funkcja)
        return res
```

Tak stworzonÄ… klasÄ™ moÅ¼emy juÅ¼ uÅ¼ywaÄ‡ w funkcji `stworz_zadanie`, podajÄ…c argument `rozwiazanie="meritum"`.

---

- **`float`**  strategia testÃ³w, ktÃ³ra bÄ™dzie zaokrÄ…glaÄ‡ wyniki.

Strategie testÃ³w bÄ™dÄ… najtrudniejszych do napisania. NajczÄ™Å›ciej bÄ™dÄ… nadpisywaÅ‚y metody juÅ¼ istniejÄ…cych strategii i modyfikowaÄ‡ sposÃ³b sprawdzania wynikÃ³w testÃ³w.

Aby skutecznie zaimplementowaÄ‡ takÄ… strategiÄ™, bÄ™dziemy musieli nadpisaÄ‡ dwie specjalnie wyodrÄ™bnione metody klasy `prime`:

```python
from prime import prime

DOKLADNOSCI = int(input("podaj dokÅ‚adnoÅ›Ä‡, z jakÄ… testy mogÄ… zaokrÄ…glaÄ‡: "))


class float(prime):
    """testy beda zaaokroglac oczekiwany wynik"""

    def metoda_zwracajaca_testow_bez_kolejnosci(
        self, NazwaTestu, numerTestu, zmienne, wynikWywolania, zmienne_nazwa
    ):
        return f"""    def test_Nr{numerTestu:02}_{NazwaTestu}_argumenty_{'_'.join(zmienne_nazwa)}(self):
            wynik  = {NazwaTestu}({', '.join(map(str, zmienne))})

            self.assertAlmostEqual(wynik, { wynikWywolania }, places={DOKLADNOSCI})\n"""

    def metoda_nasluchujaca_testow_bez_kolejnosci(
        self, NazwaTestu, numerTestu, zmienne, wynikWywolania, zmienne_nazwa
    ):
        return f"""    def test_Nr{numerTestu:02}_{NazwaTestu}_argumenty_{'_'.join(zmienne_nazwa)}(self):
            f = io.StringIO()
            with redirect_stdout(f):
                {NazwaTestu}({', '.join(map(str, zmienne))})
            wynik = f.getvalue().strip()

            self.assertAlmostEqual(wynik, { wynikWywolania }, places={DOKLADNOSCI})\n"""
```
Klasa `prime` ma wiele metod specjalnie wyodrÄ™bnionych do nadpisywania.

---

> Strategie nie mogÄ… od siebie zaleÅ¼eÄ‡ i muszÄ… byÄ‡ niezaleÅ¼ne. MoÅ¼na je odpaliÄ‡ w dowolnej konfiguracji.


Ograniczeniem strategii jest to, Å¼e nie przyjmuje argumentÃ³w innych niÅ¼ `input` i jest to ustalenie staÅ‚e. Jednak, jeÅ›li chcemy utworzyÄ‡ zadanie, dodajÄ…c pewne zmienne, moÅ¼emy skorzystaÄ‡ z **komend**

</details>

<details>
  <summary> ğŸ’» Komendy</summary>

## Komendy

<details>
   <summary> DziaÅ‚anie </summary>
   
W folderze [srt/Komendy](srt/Komendy) znajdujÄ… siÄ™ pliki Python z komendami. KaÅ¼dy plik zawiera **funkcje** o takiej samej nazwie, ktÃ³re wykonujÄ… odpowiedniÄ… komendÄ™.

 przykÅ‚adowa komenda wyglada tak. 
 ```python
# srt/Komendy/hello_name.py
def hello_name(imie):
    print("hello", imie)
```

Takiej komendy moÅ¼emy uÅ¼yÄ‡ w `szablon.py`, importujÄ…c z `testy` funkcjÄ™ `komenda` i przekazujÄ…c w pierwszym argumencie nazwÄ™ komendy, a nastÄ™pnie kolejne argumenty.
```python
# ====================================================================================================>
# Zadanie 1
# Wypisac swoje imie
# ====================================================================================================>

def Zadanie_1(): ...

if __name__ == "__main__":
    from testy01 import odpal_testy, komenda

    komenda("hello_name", "kamil")

    # Zadanie_1()
    # odpal_testy()
```
- w pliku `prototyp.py` importujemy z `Develop` funkcje komenda

Wynik odpalenia takiego programu bÄ™dzie: `hello kamil`

Taka funkcjonalnoÅ›Ä‡ pozwala w prosty sposÃ³b rozszerzaÄ‡ projekt o nowe komendy, umoÅ¼liwiajÄ…c ulepszanie testÃ³w, na przykÅ‚ad poprzez dodawanie dodatkowych testÃ³w lub wariacji poprawnego wyniku, a takÅ¼e wprowadzanie wÅ‚asnych preferencji, takich jak dodatkowe zachowanie po przejsciu testÃ³w na szablonie.

</details>

<details  >
  <summary><strong> SPIS KOMEND </strong> </summary>

### Legenda 
- `nazwaKomendy`, `mozliiwy do uzycia skrot`
- w budowie oznacza, Å¼e nie chce mi sie jej robiÄ‡
- lokalna oznacza, Å¼e jej dziaÅ‚anie nie moze wyjÅ›Ä‡ poza lokalne repozytorium. By uniknÄ…Ä‡ przypadkow, Å¼e ktos nie spodziwal ze mu poleci [najlepsza  domyslna piosenka zwycieska](https://www.youtube.com/watch?v=CpeJiGDVMGo) po napisaniu szablonu
- Zapis `link_do_muzyki="https://www.youtube.com/watch?v=CpeJiGDVMGo` oznacza ze zmienna `link_do_muzyki` jest opcjonalna i domyslnie uzyjemy `https://www.youtube.com/watch?v=CpeJiGDVMGo`



### Spis 
  - `zmien_testy`
    ```python
    # tworzy na nowo zadanie na bazie szablonu jako prototyp
    komenda("zmien_testy", [funkcje], testy="domyslna", rozwiazanie="domyslna", szablon="domyslna")
     ```

  
  - `dodaj_testy`, `dt` - w budowie
    ```python
    # dodaje  dodatkowe testy 
    komenda("dodaj_testy", funkcja, ilosci_dodatkowych_testow)
     ```
     
  - `dodaj_wariancje`, `dw` - w budowie
    ```python
    # Do istniejacych juz wynikow testow funkcji dodaje kolejne mozliwe warienty na podstawie funkcji przeslanej
    komenda("dodaj_wariancje", funkcja)
     ```
  - `zwycieska_muzyka`,`zm` - w budowie, lokalna
    ```python
    # Do testow danego zadania dodaje muzyka po zaliczeniu testow w szablonie
    # imo must have 
    komenda("zwycieska_muzyka", link_do_muzyki="https://www.youtube.com/watch?v=CpeJiGDVMGo" )
     ```
 - `funkcja_input`,`fi` - w budowie
    ```python
    # szybkie testowanie funkcji na parametrach
    # dopoki nie przerwiesz bedziesz wpisywac input a komenda uzyje jej na funkcji i wypisze output
    komenda("szybka_funkcja", funkcja )
     ```
    
  - `StworzStruktureWDI`
    ```python
    # Nie bedzie wiecej uzywana i nawet nie da sie jej odpalic z poziomu plikow zadaÅ„ - Takie zabezpieczenie
    # Ale dodaje jako taka ciekawostka oraz na przyszlosci do tworzenia struktur innych zadan
    komenda("StworzStruktureWDI")
     ```

</details>

<details  >
  <summary> OgÃ³lne </summary>
   
### Argumenty
Funkcja `komenda` przyjmuje `"nazwaKomendy"`, `*args` oraz `**kwargs`, co pozwala na przesyÅ‚anie dowolnych argumentÃ³w zarÃ³wno w postaci argumentÃ³w pozycyjnych, jak i nazwanych. Aby uÅ‚atwiÄ‡ korzystanie, dodatkowo sÄ… dodawane dwa argumenty, jeÅ›li komenda ich wymaga. Nie ma obowiÄ…zku ich podawania podczas wywoÅ‚ania komendy, sÄ… to: 
  - `nr_zadania`
  - `sciezka`
WiÄ™c komenda:
 ```python
# srt/Komendy/hello_zadanie.py
def hello_zadanie(nr_zadania, sciezka):# trzeba pamietac by nazwac te argumenty dokladnie tak 
    print("hello", nr_zadania, "from ", sciezka)
```
MoÅ¼e byÄ‡ wywoÅ‚ana w nastÄ™pujÄ…cy sposÃ³b:
 ```python
# prototyp01.py
komenda("hello_zadanie")
```
Wynik takiej komendy to:

`hello 01 from  /Users/user/Desktop/projekty/WDI-RST/Zestaw_1:_Proste_programy_z_pÄ™tlami/prototyp01.py`



### skroty 

   Jesli komenda jest czesto uÅ¼ywana moÅ¼e miec swÃ³j skrÃ³t w pliku `_skroty.py`, ktÃ³ry tylko importuje komendÄ™ i jÄ… odpala.
  ```python
  def hz(nr_zadania, sciezka):
    from hello_zadanie import hello_zadanie

    hello_zadanie(nr_zadania, sciezka)
   ```

### Zasady komend

- KaÅ¼da ma mieÄ‡ swÃ³j plik i ograniczaÄ‡ sie tylko do niego nawet jakby plik miaÅ‚by mieÄ‡ 20 linijek lub 100000 linijek.
- KaÅ¼da komenda musi byÄ‡ w peÅ‚ni niezaleÅ¼na i dziaÅ‚aÄ‡ poprawnie samodzielnie, ale moÅ¼e wywoÅ‚ywaÄ‡ inne komendy w ramach swoich dziaÅ‚aÅ„ [zgodnie z wzorcem Å‚aÅ„cucha zobowiÄ…zaÅ„]( https://refactoring.guru/pl/design-patterns/chain-of-responsibility)

</details>
</details>
